/* Autogenerated by /opt/linuxcnc/bin/halcompile on Wed Jun 23 06:57:29 2021 -- do not edit */
#include "rtapi.h"
#ifdef RTAPI
#include "rtapi_app.h"
#endif
#include "rtapi_string.h"
#include "rtapi_errno.h"
#include "hal.h"
#include "rtapi_math64.h"

static int comp_id;

#ifdef MODULE_INFO
MODULE_INFO(linuxcnc, "component:scurve:scurve component");
MODULE_INFO(linuxcnc, "descr:\nScurve Component\n\nCompile slogan :\n/opt/linuxcnc/bin/halcompile --compile /opt/linuxcnc/src/hal/components/scurve.comp\n\nPreprocess slogan :\n/opt/linuxcnc/bin/halcompile --preprocess /opt/linuxcnc/src/hal/components/scurve.comp\n\nThen copy it to the rtlib.\n\nThen in halview : loadrt scurve\n\nUsage :\n\nsetp scurve.pahtlenght 100\nsetp scurve.vo 0\nsetp scurve.ve 0\nsetp scurve.vs 5\nsetp scurve.acc-linear 2\nsetp scurve.dcc-linear 2\nsetp scurve.verbose 1\nsetp scurve.time-interval 0.001 // servo-thread time\n\nAnd then enable :\nsetp scurve.enable 1\n\n");
MODULE_INFO(linuxcnc, "author:Skynet 2021");
MODULE_INFO(linuxcnc, "license:GPLv2 or greater");
MODULE_INFO(linuxcnc, "pin:values_ok:bit:0:out:a check if mimimal required values are given (pathlenght, acc_lineair, dcc_lineair, time_interval):None:None");
MODULE_INFO(linuxcnc, "pin:demo_mode:bit:0:in:sets the timestamp +1ms and loops the scurve:None:None");
MODULE_INFO(linuxcnc, "pin:pathlenght:float:0:in:path lenght in mm:None:None");
MODULE_INFO(linuxcnc, "pin:vs:float:0:in:max velocity:None:None");
MODULE_INFO(linuxcnc, "pin:vo:float:0:in:start velocity or initial velocity:None:None");
MODULE_INFO(linuxcnc, "pin:ve:float:0:in:end velocity:None:None");
MODULE_INFO(linuxcnc, "pin:acc_lineair:float:0:in:lineair acceleration, mm/sec^2, acceleration stage:None:None");
MODULE_INFO(linuxcnc, "pin:acc_begin:float:0:in:initial acceleration, used in concave period only, exotic function:None:None");
MODULE_INFO(linuxcnc, "pin:dcc_lineair:float:0:in:lineair de-acceleration, mm/sec^2, de-acceleration stage, this value may be higher then Acc_linear:None:None");
MODULE_INFO(linuxcnc, "pin:dcc_end:float:0:in:end acceleration, used in concave period only, exotic function:None:None");
MODULE_INFO(linuxcnc, "pin:time_interval:float:0:in:the resolution of the timer, standard=0.001=1ms:None:None");
MODULE_INFO(linuxcnc, "pin:time_stamp:float:0:in:request scurve values (velocity, acceleration, etc) at a certain timestamp:None:None");
MODULE_INFO(linuxcnc, "pin:verbose:bit:0:in:verbose output 0 or 1:None:None");
MODULE_INFO(linuxcnc, "pin:t1:float:0:out:acceleration time:None:None");
MODULE_INFO(linuxcnc, "pin:t2:float:0:out:atspeed time, steady stage:None:None");
MODULE_INFO(linuxcnc, "pin:t3:float:0:out:de-acceleration time:None:None");
MODULE_INFO(linuxcnc, "pin:ttot:float:0:out:total time of path (T1+T2+T3):None:None");
MODULE_INFO(linuxcnc, "pin:l1:float:0:out:acceleration lenght:None:None");
MODULE_INFO(linuxcnc, "pin:l2:float:0:out:atspeed lenght, steady stage:None:None");
MODULE_INFO(linuxcnc, "pin:l3:float:0:out:de-acceleration lenght:None:None");
MODULE_INFO(linuxcnc, "pin:ltot:float:0:out:total path lenght (L1+L2+L3):None:None");
MODULE_INFO(linuxcnc, "pin:acc_concave:float:0:out:displacement convave period acc, curve up, document page 1:None:None");
MODULE_INFO(linuxcnc, "pin:acc_convex:float:0:out:displacement convex period acc, curve down:None:None");
MODULE_INFO(linuxcnc, "pin:acc:float:0:out:displacement acc period, s_acc_concave + s_acc_convex:None:None");
MODULE_INFO(linuxcnc, "pin:steady:float:0:out:displacement atspeed/steady period:None:None");
MODULE_INFO(linuxcnc, "pin:dcc_convex:float:0:out:displacement convex period dcc, curve down. (one position for last curve segment):None:None");
MODULE_INFO(linuxcnc, "pin:dcc_concave:float:0:out:displacement convave period dcc, curve up. (last curve segment):None:None");
MODULE_INFO(linuxcnc, "pin:dcc:float:0:out:dispalcement dcc period, s_dcc_convex + s_dcc_concave:None:None");
MODULE_INFO(linuxcnc, "pin:r_displacment:float:0:out:displacement(s) of the scurve in mm:None:None");
MODULE_INFO(linuxcnc, "pin:r_velocity:float:0:out:velocity:None:None");
MODULE_INFO(linuxcnc, "pin:r_acceleration:float:0:out:acceleration:None:None");
MODULE_INFO(linuxcnc, "pin:r_jerk:float:0:out:jerk:None:None");
MODULE_INFO(linuxcnc, "funct:_:1:");
MODULE_LICENSE("GPLv2 or greater");
#endif // MODULE_INFO


struct __comp_state {
    struct __comp_state *_next;
    hal_bit_t *values_ok;
    hal_bit_t *demo_mode;
    hal_float_t *pathlenght;
    hal_float_t *vs;
    hal_float_t *vo;
    hal_float_t *ve;
    hal_float_t *acc_lineair;
    hal_float_t *acc_begin;
    hal_float_t *dcc_lineair;
    hal_float_t *dcc_end;
    hal_float_t *time_interval;
    hal_float_t *time_stamp;
    hal_bit_t *verbose;
    hal_float_t *t1;
    hal_float_t *t2;
    hal_float_t *t3;
    hal_float_t *ttot;
    hal_float_t *l1;
    hal_float_t *l2;
    hal_float_t *l3;
    hal_float_t *ltot;
    hal_float_t *acc_concave;
    hal_float_t *acc_convex;
    hal_float_t *acc;
    hal_float_t *steady;
    hal_float_t *dcc_convex;
    hal_float_t *dcc_concave;
    hal_float_t *dcc;
    hal_float_t *r_displacment;
    hal_float_t *r_velocity;
    hal_float_t *r_acceleration;
    hal_float_t *r_jerk;
};
struct __comp_state *__comp_first_inst=0, *__comp_last_inst=0;

static void _(struct __comp_state *__comp_inst, long period);
static int __comp_get_data_size(void);
#undef TRUE
#define TRUE (1)
#undef FALSE
#define FALSE (0)
#undef true
#define true (1)
#undef false
#define false (0)

static int export(char *prefix, long extra_arg) {
    char buf[HAL_NAME_LEN + 1];
    int r = 0;
    int sz = sizeof(struct __comp_state) + __comp_get_data_size();
    struct __comp_state *inst = hal_malloc(sz);
    memset(inst, 0, sz);
    r = hal_pin_bit_newf(HAL_OUT, &(inst->values_ok), comp_id,
        "%s.values-ok", prefix);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_IN, &(inst->demo_mode), comp_id,
        "%s.demo-mode", prefix);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_IN, &(inst->pathlenght), comp_id,
        "%s.pathlenght", prefix);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_IN, &(inst->vs), comp_id,
        "%s.vs", prefix);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_IN, &(inst->vo), comp_id,
        "%s.vo", prefix);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_IN, &(inst->ve), comp_id,
        "%s.ve", prefix);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_IN, &(inst->acc_lineair), comp_id,
        "%s.acc-lineair", prefix);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_IN, &(inst->acc_begin), comp_id,
        "%s.acc-begin", prefix);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_IN, &(inst->dcc_lineair), comp_id,
        "%s.dcc-lineair", prefix);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_IN, &(inst->dcc_end), comp_id,
        "%s.dcc-end", prefix);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_IN, &(inst->time_interval), comp_id,
        "%s.time-interval", prefix);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_IN, &(inst->time_stamp), comp_id,
        "%s.time-stamp", prefix);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_IN, &(inst->verbose), comp_id,
        "%s.verbose", prefix);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_OUT, &(inst->t1), comp_id,
        "%s.t1", prefix);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_OUT, &(inst->t2), comp_id,
        "%s.t2", prefix);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_OUT, &(inst->t3), comp_id,
        "%s.t3", prefix);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_OUT, &(inst->ttot), comp_id,
        "%s.ttot", prefix);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_OUT, &(inst->l1), comp_id,
        "%s.l1", prefix);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_OUT, &(inst->l2), comp_id,
        "%s.l2", prefix);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_OUT, &(inst->l3), comp_id,
        "%s.l3", prefix);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_OUT, &(inst->ltot), comp_id,
        "%s.ltot", prefix);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_OUT, &(inst->acc_concave), comp_id,
        "%s.acc-concave", prefix);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_OUT, &(inst->acc_convex), comp_id,
        "%s.acc-convex", prefix);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_OUT, &(inst->acc), comp_id,
        "%s.acc", prefix);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_OUT, &(inst->steady), comp_id,
        "%s.steady", prefix);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_OUT, &(inst->dcc_convex), comp_id,
        "%s.dcc-convex", prefix);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_OUT, &(inst->dcc_concave), comp_id,
        "%s.dcc-concave", prefix);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_OUT, &(inst->dcc), comp_id,
        "%s.dcc", prefix);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_OUT, &(inst->r_displacment), comp_id,
        "%s.r-displacment", prefix);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_OUT, &(inst->r_velocity), comp_id,
        "%s.r-velocity", prefix);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_OUT, &(inst->r_acceleration), comp_id,
        "%s.r-acceleration", prefix);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_OUT, &(inst->r_jerk), comp_id,
        "%s.r-jerk", prefix);
    if(r != 0) return r;
    rtapi_snprintf(buf, sizeof(buf), "%s", prefix);
    r = hal_export_funct(buf, (void(*)(void *inst, long))_, inst, 1, 0, comp_id);
    if(r != 0) return r;
    if(__comp_last_inst) __comp_last_inst->_next = inst;
    __comp_last_inst = inst;
    if(!__comp_first_inst) __comp_first_inst = inst;
    return 0;
}
int rtapi_app_main(void) {
    int r = 0;
    comp_id = hal_init("scurve");
    if(comp_id < 0) return comp_id;
    r = export("scurve", 0);
    if(r) {
        hal_exit(comp_id);
    } else {
        hal_ready(comp_id);
    }
    return r;
}

void rtapi_app_exit(void) {
    hal_exit(comp_id);
}

#undef FUNCTION
#define FUNCTION(name) static void name(struct __comp_state *__comp_inst, long period)
#undef EXTRA_SETUP
#define EXTRA_SETUP() static int extra_setup(struct __comp_state *__comp_inst, char *prefix, long extra_arg)
#undef EXTRA_CLEANUP
#define EXTRA_CLEANUP() static void extra_cleanup(void)
#undef fperiod
#define fperiod (period * 1e-9)
#undef values_ok
#define values_ok (*__comp_inst->values_ok)
#undef demo_mode
#define demo_mode (0+*__comp_inst->demo_mode)
#undef pathlenght
#define pathlenght (0+*__comp_inst->pathlenght)
#undef vs
#define vs (0+*__comp_inst->vs)
#undef vo
#define vo (0+*__comp_inst->vo)
#undef ve
#define ve (0+*__comp_inst->ve)
#undef acc_lineair
#define acc_lineair (0+*__comp_inst->acc_lineair)
#undef acc_begin
#define acc_begin (0+*__comp_inst->acc_begin)
#undef dcc_lineair
#define dcc_lineair (0+*__comp_inst->dcc_lineair)
#undef dcc_end
#define dcc_end (0+*__comp_inst->dcc_end)
#undef time_interval
#define time_interval (0+*__comp_inst->time_interval)
#undef time_stamp
#define time_stamp (0+*__comp_inst->time_stamp)
#undef verbose
#define verbose (0+*__comp_inst->verbose)
#undef t1
#define t1 (*__comp_inst->t1)
#undef t2
#define t2 (*__comp_inst->t2)
#undef t3
#define t3 (*__comp_inst->t3)
#undef ttot
#define ttot (*__comp_inst->ttot)
#undef l1
#define l1 (*__comp_inst->l1)
#undef l2
#define l2 (*__comp_inst->l2)
#undef l3
#define l3 (*__comp_inst->l3)
#undef ltot
#define ltot (*__comp_inst->ltot)
#undef acc_concave
#define acc_concave (*__comp_inst->acc_concave)
#undef acc_convex
#define acc_convex (*__comp_inst->acc_convex)
#undef acc
#define acc (*__comp_inst->acc)
#undef steady
#define steady (*__comp_inst->steady)
#undef dcc_convex
#define dcc_convex (*__comp_inst->dcc_convex)
#undef dcc_concave
#define dcc_concave (*__comp_inst->dcc_concave)
#undef dcc
#define dcc (*__comp_inst->dcc)
#undef r_displacment
#define r_displacment (*__comp_inst->r_displacment)
#undef r_velocity
#define r_velocity (*__comp_inst->r_velocity)
#undef r_acceleration
#define r_acceleration (*__comp_inst->r_acceleration)
#undef r_jerk
#define r_jerk (*__comp_inst->r_jerk)


#line 90 "/opt/linuxcnc/src/hal/components/scurve.comp"

#include "rtapi_math.h"
#include "scurve.h"

double ms;
double seconds;
double totalnsec;

FUNCTION(_) {

    // Scurve traject.
    if(!demo_mode && pathlenght>0 && vs>0 && acc_lineair>0 && dcc_lineair>0){   // Check if we have at least the minimal required values.
        values_ok=true;
        struct result r;                                    // Structure that holds the results.
        r=request_trajectcalculator_scurve(vs,			 	// velmax.
                                           acc_lineair,     // accmax.
                                           dcc_lineair,     // dccmax.
                                           acc_begin,       // accbegin.
                                           dcc_end,         // dccend.
                                           vo, 				// vbegin.
                                           ve, 				// vend.
                                           pathlenght,      // pathlenght.
                                           time_stamp,      // request at time(t) in sec.
                                           verbose);        // debug 0 or 1.

        // Copy the results(r) to hal float output pins.
        r_displacment=r.s;
        r_velocity=r.v;
        r_acceleration=r.a;
        r_jerk=r.j;
    } else {
        values_ok=false;
    }

    // Scurve traject demo. Check output with halscope.
    if(demo_mode){  
        // Demo timer.
        totalnsec = totalnsec + period;
        ms = totalnsec * 0.000001;          // rtapi_print_msg(RTAPI_MSG_ERR,"totalms: %f \n", totalms);
        seconds = totalnsec * 0.000000001;  // rtapi_print_msg(RTAPI_MSG_ERR,"totalseconds: %f \n", totalseconds);
        
        struct result r;                                    // Structure that holds the results.
        r=request_trajectcalculator_scurve(5,			 	// velmax.
                                           2,               // accmax.
                                           3,               // dccmax.
                                           0,               // accbegin.
                                           0,               // dccend.
                                           1, 				// vbegin.
                                           0, 				// vend.
                                           50,              // pathlenght.
                                           seconds,         // request at time(t) in sec.
                                           1);              // debug 0 or 1.  

        // Copy the results to hal float output pins.
        r_displacment=r.s;
        r_velocity=r.v;
        r_acceleration=r.a;
        r_jerk=r.j;

        if(seconds>=r.t){ // Scurve completed, reset time.
            totalnsec=0;
            seconds=0;
            ms=0;
        }
    }
}






















static int __comp_get_data_size(void) { return 0; }
